TCP에서 서버와 클라이언트의 문제점

하나의 프로그램은 기본적으로 하나의 스레드를 가지고 있으므로,
여러 클라이언트가 하나의 서버에 접속할 경우 서버가 하나의 스레드를
가지고 처리할 역량이 부족하므로 클라이언트 마다 별도의 스레드를 생성해줘야
한다.

문제점 : 
    1. 채팅 순서가 정해진 대로 밖에 진행이 안됨
    2. 서버와 클라이언트가 동시에 read()를 호출하면 교착상태가 발생함

해결 : 
    1.
    
        멀티 프로세스 - 프로세스를 복사하여 송신,수신을 처리하며 각 클라이언트를 담당함
            장점 - 구현이 쉬움
            단점 - 프로세스의 PCB를 그대로 복사하므로 메모리 사용량 증가 및
                   프로세스 스케쥴링 횟수가 많아짐. 프로세스간 데이터 공유가
                   불편하여 IPC를 사용해야 함. IPC를 사용하면 프로그램의 복
                   잡성이 증가하는 문제.
        
        멀티 스레드 - 스레드를 생성하여 송신,수신을 처리하며 각 클라이언트를 담당함
            장점 - 구현이 쉬움
            단점 - 멀티 프로세스 보다는 메모리를 덜 낭비하나 stack 영역은 복사를 함

        논블로킹 IO - 각 클라이언트의 송신이나 수신 신호를 받아 서비스를 제공
                     자바에서는 이를 NewIO(NIO)라고 칭함
            장점 - 소수의 스레드를 이용해 다수의 클라이언트를 지원
            단점 - 구현이 어려움

    2.
        데이터 송수신부분 잘 설계하기
            장점 - 언어에 상관없이 프로그래밍적으로 설계 가능
            단점 - 모든 경우에 대한 해결책은 아님

        소켓에 타임아웃 옵션 적용하기
            장점 - 구현이 쉬움
            단점 - 타임아웃에 따른 지연 시간으로
                   다른 방법에 비해 성능이 낮음

        넌블로킹 소켓 사용하기
            장점 - 근본적으로 교착 상태 해결
            단점 - 구현이 복잡하며, 시스템 자원 낭비!!

